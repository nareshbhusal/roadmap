import Dexie, { Table } from "dexie";
import type { IdeaData, StoriesTag, IdeasTag, IdeaPreview, IdeaCreateForm, IdeaCreateRequest, IdeaUpdateForm } from '../types';

// TODO: There must be some best-practice pattern for this problem where you need just some slight adjustment
// to the type interface, one for form values, one for the server request, and one for the database.
// TODO: God, please make the types less fugly
//
// TODO: We'll have multiple boards, multiple projects, and one organization.

export interface StoreIdea extends Omit<IdeaData, 'tags'> {
  tagIDs: number[];
}

// TODO: Add a user by default

class IdeasDB extends Dexie {
  ideas!: Table<StoreIdea, number>;
  ideasTags!: Table<IdeasTag, number>;
  storiesTags!: Table<StoriesTag, number>;

  constructor() {
    super("roadmapDB");

    // NOTE: Are the types that we've associated with the tables above the same for the data we push in?
    // Like the id prop is autogenerated for example right? So what's up with that?
    this.version(1).stores({
      ideas: `
        ++id,
        title,
        description,
        createdOn,
        updatedOn,
        impact,
        *tagIDs,
        effort,
        status,
        storyID,
        comments
      `,
      ideasTags: `
        ++id,
        &text
      `,
      storiesTags: `
        ++id,
        &text
      `
    });

    this.ideas = this.table("ideas");
    this.ideasTags = this.table("ideasTags");
    this.storiesTags = this.table("storiesTags");
  }

  public async addIdea(idea: IdeaCreateRequest) {
    const newIdeaData: StoreIdea = {
      ...idea,
      createdOn: Date.now(),
      updatedOn: null,
      storyID: null,
      comments: [],
      status: 'active',
    }
    return await this.ideas.add(newIdeaData);
  }

  public async deleteIdeasTag(ideasTagID: number) {
    await this.transaction("rw", this.ideas, this.ideasTags, async () => {
      await this.ideasTags.delete(ideasTagID);
      // remove ideasTagID from all ideas' tagIDs[]
      await this.ideas.where("tagIDs").equals(ideasTagID).modify(idea => {
        idea.tagIDs = idea.tagIDs.filter((tagID: number) => tagID !== ideasTagID);
      });
    });
  }

  public async getIdea(ideaID: number): Promise<IdeaData | undefined> {
    const idea = await this.ideas.get(ideaID);
    // return idea, but with tagIDs replaced by actual ideasTags objects
    if (idea) {
      let tags = await Promise.all(idea.tagIDs.map(async (tagID: number) => {
        const tag = await this.ideasTags.get(tagID) as IdeasTag;
        return tag;
      }));
      tags = tags.filter((tag: IdeasTag | undefined) => tag !== undefined);

      const ideaToSend = {
        ...idea,
        tags
      }
      return ideaToSend;
    }
  }

  public async getIdeas(): Promise<IdeaPreview[]> {
    const ideas = await this.ideas.toArray();

    return await Promise.all(ideas.map(async (idea: StoreIdea) => {

      let tags = await Promise.all(idea.tagIDs.map(async (tagID: number) => {
        const tag = await this.ideasTags.get(tagID) as IdeasTag;
        return tag;
      }));

      tags = tags.filter((tag: IdeasTag | undefined) => tag !== undefined);

      let previewIdea = {
        id: idea.id,
        title: idea.title,
        impact: idea.impact,
        effort: idea.effort,
        status: idea.status,
        createdOn: idea.createdOn,
        updatedOn: idea.updatedOn,
        storyID: idea.storyID,
        tags,
        comments: idea.comments.length,
      };
      return previewIdea;
    }));
  }

  public async getIdeasTags(): Promise<IdeasTag[]> {
    return await this.ideasTags.toArray();
  }

  public async addIdeasTag(tag: string) {
    return await this.ideasTags.add({
      text: tag
    });
  }

  public async updateIdea(id: number, idea: IdeaUpdateForm) {
    return await this.ideas.update(id, {
      ...idea,
      updatedOn: Date.now(),
    });
  }
}

export const db = new IdeasDB();

const populateDB = async () => {
  // TODO: do this
  // db.ideas.bulkAdd(ideas);
};

db.on("populate", populateDB);

db.open().then(function (db) {
    // Database opened successfully
}).catch (function (err) {
    // Error occurred
});

export function resetDatabase() {
  return db.transaction('rw', db.ideas, db.ideas, async () => {
    await Promise.all(db.tables.map(table => table.clear()));
    await populateDB();
  });
}
